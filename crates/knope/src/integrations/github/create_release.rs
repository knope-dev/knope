use datta::UriTemplate;
use glob::glob;
use knope_config::{Asset, AssetNameError, Assets};
use miette::Diagnostic;
use relative_path::RelativePathBuf;
use tracing::info;
use ureq::Response;

use crate::{
    app_config, config,
    integrations::{
        CreateReleaseInput, CreateReleaseResponse, github::initialize_state, ureq_err_to_string,
    },
    state,
    state::RunType,
};

pub(crate) fn create_release(
    name: &str,
    tag_name: &str,
    body: &str,
    prerelease: bool,
    github_state: RunType<state::GitHub>,
    github_config: &config::GitHub,
    assets: Option<&Assets>,
) -> Result<state::GitHub, Error> {
    let github_release =
        CreateReleaseInput::new(tag_name, name, body, prerelease, assets.is_some());

    let github_state = match github_state {
        RunType::DryRun(state) => {
            github_release_dry_run(name, assets, &github_release)?;
            return Ok(state);
        }
        RunType::Real(github_state) => github_state,
    };

    let (token, agent) = initialize_state(github_state)?;

    let url = format!(
        "https://api.github.com/repos/{owner}/{repo}/releases",
        owner = github_config.owner,
        repo = github_config.repo,
    );
    let token_header = format!("token {}", &token);

    let response = agent
        .post(&url)
        .set("Authorization", &token_header)
        .send_json(github_release)
        .map_err(|source| Error::ApiRequest {
            err: ureq_err_to_string(source),
            activity: "creating a release".to_string(),
        })
        .and_then(|resp| error_on_bad_http_status(resp, "creating a release".to_string()))?;

    let response: CreateReleaseResponse =
        response.into_json().map_err(|source| Error::ApiResponse {
            message: source.to_string(),
            activity: "creating a release".to_string(),
        })?;

    if let Some(assets) = assets {
        let mut upload_template = UriTemplate::new(&response.upload_url);
        for asset in resolve_assets(assets)? {
            let file = std::fs::read(asset.path.to_path("")).map_err(|source| {
                Error::CouldNotReadAssetFile {
                    path: asset.path.clone(),
                    source,
                }
            })?;
            let asset_name = asset.name()?;
            let upload_url = upload_template.set("name", asset_name.as_str()).build();
            agent
                .post(&upload_url)
                .set("Authorization", &token_header)
                .set("Content-Type", "application/octet-stream")
                .set("Content-Length", &file.len().to_string())
                .send_bytes(&file)
                .map_err(|source| Error::ApiRequest {
                    err: ureq_err_to_string(source),
                    activity: format!(
                        "uploading asset {asset_name}. Release has been created but not published!",
                    ),
                })
                .and_then(|resp| {
                    error_on_bad_http_status(
                        resp,
                        format!(
                            "uploading asset {asset_name}. Release has been created but not published!",
                        ),
                    )
                })?;
        }
        agent
            .patch(&response.url)
            .set("Authorization", &token_header)
            .send_json(ureq::json!({
                "draft": false
            }))
            .map_err(|source| Error::ApiRequest {
                err: ureq_err_to_string(source),
                activity: "publishing release".to_string(),
            })
            .and_then(|resp| error_on_bad_http_status(resp, "publishing release".to_string()))?;
    }

    Ok(state::GitHub::Initialized { token, agent })
}

fn error_on_bad_http_status(response: Response, activity: String) -> Result<Response, Error> {
    if response.status() >= 400 {
        let num = response.status();
        let text = response.status_text().to_string();
        let message = if let Ok(body) = response.into_string() {
            format!("Got HTTP status {num} {text} with body {body}")
        } else {
            format!("Got HTTP status {num} {text}")
        };
        Err(Error::ApiResponse { message, activity })
    } else {
        Ok(response)
    }
}

fn github_release_dry_run(
    name: &str,
    assets: Option<&Assets>,
    github_release: &CreateReleaseInput,
) -> Result<(), Error> {
    let release_type = if github_release.prerelease {
        "prerelease"
    } else {
        "release"
    };
    let body = github_release.body.as_ref().map_or_else(
        || String::from("autogenerated body"),
        |body| format!("body:\n{body}"),
    );
    info!(
        "Would create a {release_type} on GitHub with name {name} and tag {tag} and {body}",
        tag = github_release.tag_name
    );

    let Some(assets) = assets else {
        return Ok(());
    };
    info!("Would upload assets to GitHub:");

    let assets = resolve_assets(assets)?;
    for asset in assets {
        let asset_name = asset.name()?;
        info!("- {asset_name} from {path}", path = asset.path);
    }
    Ok(())
}

fn resolve_assets(assets: &Assets) -> Result<Vec<Asset>, Error> {
    match assets {
        Assets::Glob(pattern) => glob(pattern)?
            .map(|path| {
                let path = RelativePathBuf::from_path(&path?)?;
                Ok(Asset { path, name: None })
            })
            .collect(),
        Assets::List(assets) => Ok(assets.clone()),
    }
}

#[derive(Debug, Diagnostic, thiserror::Error)]
pub(crate) enum Error {
    #[error(
        "Could not read asset file {path}: {source} Release has been created but not published!"
    )]
    #[diagnostic(
        code(step::could_not_read_asset_file),
        help(
            "This could be a permissions issue or the file may not exist relative to the current working directory."
        )
    )]
    CouldNotReadAssetFile {
        path: RelativePathBuf,
        source: std::io::Error,
    },
    #[error(transparent)]
    #[diagnostic(transparent)]
    AppConfig(#[from] app_config::Error),
    #[error("Trouble communicating with GitHub while {activity}: {err}")]
    #[diagnostic(
        code(github::api_request_error),
        help(
            "There was a problem communicating with GitHub, this may be a network issue or a permissions issue."
        )
    )]
    ApiRequest { err: String, activity: String },
    #[error("Trouble decoding the response from GitHub while {activity}: {message}")]
    #[diagnostic(
        code(github::api_response_error),
        help(
            "Failure to decode a response from GitHub is probably a bug. Please report it at https://github.com/knope-dev/knope"
        )
    )]
    ApiResponse { message: String, activity: String },
    #[error("Asset was not uploaded to GitHub, a release was created but is still a draft! {0}")]
    #[diagnostic(
        code(github::asset_name_error),
        help("Try setting the `name` property of the asset manually"),
        url("https://knope.tech/reference/config-file/packages/#assets")
    )]
    AssetName(#[from] AssetNameError),
    #[error("Invalid glob pattern: {0}")]
    Pattern(#[from] glob::PatternError),
    #[error("Could not evaluate glob pattern: {0}")]
    Glob(#[from] glob::GlobError),
    #[error("Could not resolve asset path: {0}")]
    #[diagnostic(
        code(step::could_not_resolve_asset_path),
        help(
            "This could be a permissions issue or the file may not exist relative to the current working directory."
        )
    )]
    AssetPath(#[from] relative_path::FromPathError),
}
